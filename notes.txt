Features
*** Pass Ambient Color, Diffuse Color, Specular Color, Shininess, Dissolve(alpha channel), Optical_density????
*** Create Mipmap System for the graphic


Negative Y is up
Positive Y is down

Negative Z is Backward
Positive Z is Forward

Negative X is Left
Positive X is Right

// Forward Rendering refer to a rendering technique that traditional has only two passes.
// 1) Opaque Pass
// 2) Transparent Pass

// Forward+ Rendering refer to a rendering technique that expend on the traditional technique and has three passes.
// 1) Light Culling
// 2) Opaque Pass
// 3) Transparent Pass


//killzone 2 uses the following equation to pack the specular power value
// a' = log2 a / 10.5
// exp2( specular.a * 10.5f );


// if the diffuse color for the material will be multiplied by the texture sample rgb value
// eg. if the texture r = 0.345 and the material diffuse r = 0.0 then the output will be 0.0;

//todo Rendering
// todo re-read 154 to 159 to understand and implement ScissorRect for lighting and decide which folder the method should be in.
// todo re-read 160 to 162 to  understand and implement Depth Bounds for lighting and decide which folder the method should be in.
// todo re-read 162 to 169 to understand and implement Oblique Depth Bounds for lighting and decide which folder the method should be in.

//todo Clean Solution
//todo Destroy buffer when done.

//todo the model should have a render_pipeline since we want to support future shader customization for the model.

//todo work on the texture next.

//todo Prefer moving the loop inside run and move borrow's call outside the loop
//todo Division is an expensive operation use reciprocal
//todo for passes should i store the required data in a pass file and decode it when doing the render passes?
//todo when releasing use cargo run --release -- -C opt-level=3 -C target-cpu=skylark -C target-feature=+sse3,+avx

first scale then rotate then translate.

transfromation matrix formula

[scale.x * cos(angle.y) * cos(angle.z),          -sin(angle.z),          sin(angle.y),           position.x]
[sin(angle.z),          scale.y * cos(angle.x) * cos(angle.z),          -sin(angle.x),           position.y]
[-sin(angle.y),           sin(angle.x),          scale.z * cos(angle.x) *  cos(angle.y),         position.z]
[0,                                                 0,                             0,                     1]

cargo miri test
cargo miri run

Reference game engine

Defold, Amethyst, Bevy, Cocos2d, Coffee, Cryengine, Godot, Macroquad, Monogame, Panda3d, R3D, Stride


Look at cocos2d-x-4 CCTextureUtils.h and CCTextureUtils.cpp for texture conversion.

